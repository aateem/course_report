\section{ОБЗОР ИСПОЛЬЗУЕМЫХ ТЕХНОЛОГИЙ}
\label{sec:tech-overview}

\vspace{0.6cm}

Для реализации задачи данного курсового проекта использовались следующие
технологии:

\begin{enumerate}
    \item Git -- распределенная система контроля версий.

    \item Python -- высокоуровневый динамический язык программирования общего назначения.

    \item PySide -- кроссплатформенный инструментарий разработки ПО на языке программирования Python c использованием
          библиотеки классов Qt.

    \item SQLite -- легковесная встраиваемая реляционная база данных.

    

\end{enumerate}

\subsection{Обзор Git}
\label{subsec:git-overview}

Как уже отмечалось выше, Git -- это распределенная система управления версиями.

Система управления версиями -- это программное обеспечение для облегчения работы с
изменяющейся информацией. Система управления версиями позволяет хранить несколько версий
одного и того же документа, при необходимости возвращаться к более ранним версиям, определять,
кто и когда сделал то или иное изменение, и многое другое.

Такие системы наиболее широко используются при разработке программного обеспечения для
хранения исходных кодов разрабатываемой программы. Однако они могут с успехом применяться и
в других областях, в которых ведётся работа с большим количеством непрерывно изменяющихся электронных
документов.

Традиционные системы управления версиями используют централизованную модель, когда имеется единое
хранилище документов, управляемое специальным сервером, который и выполняет большую часть функций
по управлению версиями. Пользователь, работающий с документами, должен сначала получить нужную
ему версию документа из хранилища; обычно создаётся локальная копия документа, т. н. «рабочая копия».
Может быть получена последняя версия или любая из предыдущих, которая может быть выбрана по номеру
версии или дате создания, иногда и по другим признакам. После того, как в документ внесены нужные
изменения, новая версия помещается в хранилище. В отличие от простого сохранения файла, предыдущая
версия не стирается, а тоже остаётся в хранилище и может быть оттуда получена в любое время.

Git же напротив, использует распределенную модель. Он не нуждается в централизованном хранилище:
вся история изменения документов хранится на каждом компьютере, в локальном хранилище, и при
необходимости отдельные фрагменты истории локального хранилища синхронизируются с аналогичным хранилищем
на другом компьютере. В некоторых таких системах локальное хранилище располагается непосредственно в
каталогах рабочей копии.

Когда пользователь такой системы выполняет обычные действия, такие как извлечение определённой
версии документа, создание новой версии и тому подобное, он работает со своей локальной копией
хранилища. По мере внесения изменений, хранилища, принадлежащие разным разработчикам, начинают
различаться, и возникает необходимость в их синхронизации. Такая синхронизация может осуществляться
с помощью обмена патчами или так называемыми наборами изменений (англ. change sets) между
пользователями.

Описанная модель логически близка созданию отдельной ветки для каждого разработчика в классической
системе управления версиями (в некоторых распределённых системах перед началом работы с локальным
хранилищем нужно создать новую ветвь). Отличие состоит в том, что до момента синхронизации другие
разработчики этой ветви не видят. Пока разработчик изменяет только свою ветвь, его работа не влияет
на других участников проекта и наоборот. По завершении обособленной части работы, внесённые в ветви
изменения сливают с основной (общей) ветвью. Как при слиянии ветвей, так и при синхронизации разных
хранилищ возможны конфликты версий. На этот случай во всех системах предусмотрены те или иные методы
обнаружения и разрешения конфликтов слияния.

С точки зрения пользователя распределённая система отличается необходимостью создавать локальный
репозиторий и наличием в командном языке двух дополнительных команд: команды получения репозитория
от удалённого компьютера (pull) и передачи своего репозитория на удалённый компьютер (push). Первая
команда выполняет слияние изменений удалённого и локального репозиториев с помещением результата в
локальный репозиторий; вторая — наоборот, выполняет слияние изменений двух репозиториев с помещением
результата в удалённый репозиторий. Как правило, команды слияния в распределённых системах позволяют
выбрать, какие наборы изменений будут передаваться в другой репозиторий или извлекаться из него,
исправлять конфликты слияния непосредственно в ходе операции или после её неудачного завершения,
повторять или возобновлять неоконченное слияние. Обычно передача своих изменений в чужой репозиторий
(push) завершается удачно только при условии отсутствия конфликтов. Если конфликты возникают, пользователь
должен сначала слить версии в своём репозитории (выполнить pull), и лишь затем передавать их другим.

Основные преимущества распределённых систем -- их гибкость и значительно большая (по сравнению с
централизованными системами) автономия отдельного рабочего места. Каждый компьютер разработчика
является, фактически, самостоятельным и полнофункциональным сервером, из таких компьютеров можно
построить произвольную по структуре и уровню сложности систему, задав (как техническими, так и
административными мерами) желаемый порядок синхронизации. При этом каждый разработчик может вести
работу независимо, так, как ему удобно, изменяя и сохраняя промежуточные версии документов,
пользуясь всеми возможностями системы (в том числе доступом к истории изменений) даже в отсутствие
сетевого соединения с сервером. Связь с сервером или другими разработчиками требуется исключительно
для проведения синхронизации, при этом обмен наборами изменений может осуществляться по различным
схемам.

Ядро Git представляет собой набор утилит командной строки с параметрами. Все настройки хранятся в текстовых файлах конфигурации. Такая реализация делает Git легко портируемым на любую платформу и даёт возможность легко интегрировать Git в другие системы (в частности, создавать графические git-клиенты с любым желаемым интерфейсом).

Репозиторий Git представляет собой каталог файловой системы, в котором находятся файлы конфигурации репозитория, файлы журналов, хранящие операции, выполняемые над репозиторием, индекс, описывающий расположение файлов и хранилище, содержащее собственно файлы. Структура хранилища файлов не отражает реальную структуру хранящегося в репозитории файлового дерева, она ориентирована на повышение скорости выполнения операций с репозиторием. Когда ядро обрабатывает команду изменения (неважно, при локальных изменениях или при получении патча от другого узла), оно создаёт в хранилище новые файлы, соответствующие новым состояниям изменённых файлов. Существенно, что никакие операции не изменяют содержимого уже существующих в хранилище файлов.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.7]{images/git-overview.png}
    \caption{Процесс взаимодействия с Git}
    \label{fig:git-overview}
\end{figure}

Процесс взаимодействия с Git отображен на рисунке \ref{fig:git-overview}.

\subsection{Обзор Python}
\label{subsec:python-overview}

В связи с наблюдаемым в настоящее время стремительным развитием персональной вычислительной техники, происходит постепенное изменение требований,
предъявляемых к языкам программирования. Все большую роль начинают играть интерпретируемые языки, поскольку возрастающая мощь персональных компьютеров
начинает обеспечивать достаточную скорость выполнения интерпретируемых программ. А единственным существенным преимуществом компилируемых языков программирования
является создаваемый ими высокоскоростной код. Когда скорость выполнения программы не является критичной величиной, наиболее правильным выбором будет 
интерпретируемый язык, как более простой и гибкий инструмент программирования.

В связи с этим, определенный интерес представляет рассмотрение сравнительно нового языка программирования Python (пайтон),
который был создан его автором Гвидо ван Россумом (Guido van Rossum) в начале 90-х годов.

Python является интерпретируемым, изначально объектно-ориентированным языком программирования. Он чрезвычайно прост и содержит небольшое число ключевых слов, вместе с тем очень гибок и выразителен. Это язык более высокого уровня нежели Pascal, C++ и, естественно C,
что достигается, в основном, за счет встроенных высокоуровневых структур данных (списки, словари, тьюплы).

Несомненным достоинством является то, что интерпретатор Python реализован практически на всех платформах и операционных системах.
Первым таким языком был C, однако его типы данных на разных машинах могли занимать разное количество памяти и это служило некоторым
препятствием при написании действительно переносимой программы. Python же таким недостатком не обладает.

Следующая немаловажная черта - расширяемость языка, этому придается большое значение и, как пишет сам автор, язык был задуман именно как расширяемый.
Это означает, что имеется возможность совершенствования языка всеми всеми заинтересованными программистами. Интерпретатор написан на С и исходный код 
доступен для любых манипуляций. В случае необходимости, можно вставить его в свою программу и использовать как встроенную оболочку. Или же, написав на 
C свои дополнения к Python и скомпилировав программу, получить "расширенный" интерпретатор с новыми возможностями.

Следующее достоинство - наличие большого числа подключаемых к программе модулей, обеспечивающих различные дополнительные возможности. Такие модули пишутся на
С и на самом Python и могут быть разработаны всеми достаточно квалифицированными программистами.

Единственным недостатком, замеченным автором, является сравнительно невысокая скорость выполнения Python-программы, что обусловлено ее интерпретируемостью.
Однако, на наш взгляд, это с лихвой окупается достоинствами языка при написании программ не очень критичных к скорости выполнения. 

Python, в отличие от многих языков (Pascal, C++, Java, и т.д.), не требует описания переменных. Они создаются в месте их инициализации, т.е. 
при первом присваивании переменной какого-либо значения. Значит, тип переменной определяется типом присваиваемого значения. В этом отношении Python напоминает Basic. 
Тип переменной не является неизменным. Любое присваивание для нее корректно и это приводит лишь к тому, что типом переменной становится тип нового присваиваемого значения.

В таких языках как Pascal, C, C++ организация списков представляла некоторые трудности. Для их реализации приходилось хорошо изучать принципы работы с указателями и динамической памятью. И даже имея хорошую квалификацию, программист, каждый раз заново реализуя механизмы создания, работы и уничтожения списков, мог легко допустить трудноуловимые ошибки.
Ввиду этого были созданы некоторые средства для работы со списками. Например, в Delphi Pascal имеется класс TList, реализующий списки; для С++ 
разработана библиотека STL (Standard Template Library), содержащая такие структуры как векторы, списки, множества, словари, стеки и очереди. Однако, такие средства имеются не во всех языках и их реализациях.

Python в отличие от Pascal, C, C++ не поддерживает работу с указателями, динамической памятью и адресную арифметику. В этом он похож на Java. Как известно, указатели служат источником трудноуловимых ошибок и работа с ними относится больше к программированию на низком уровне.
Для обеспечения большей надежности и простоты они небыли включены в Python.

\subsection{Обзор PySide}
\label{subsec:qt-overview}

PySide — привязка языка Python к инструментарию Qt, совместимая на уровне API с PyQt.
В отличие от PyQt, PySide доступна для свободного использования как в открытых, так и закрытых, в частности, коммерческих, 
проектах, поскольку лицензирована по LGPL.

В свою очередь, Qt -- это кроссплатформенная библиотека для разработки ПО (изначально на С++, потом была добавленна
привязка к другим популярным языкам программирования, в частности к Python), 
разрабатываемая для написания кроссплатформенных графических приложений.

Позволяет запускать написанное с его помощью ПО в большинстве современных 
операционных систем путём простой компиляции программы для каждой ОС без 
изменения исходного кода. Включает в себя все основные классы, которые могут 
потребоваться при разработке прикладного программного обеспечения, начиная от 
элементов графического интерфейса и заканчивая классами для работы с сетью, 
базами данных и XML. Qt является полностью объектно-ориентированным, легко 
расширяемым и поддерживающим технику компонентного программирования.

Существуют версии библиотеки для Microsoft Windows, систем класса UNIX с 
графической подсистемой X11, Mac OS X, Microsoft Windows CE, встраиваемых 
Linux-систем и платформы S60. Также идёт портирование на HaikuOS, iOS, Android.

До недавнего времени библиотека Qt также распространялась ещё в одной версии: 
Qt/Embedded. Теперь эта платформа переименована в Qtopia Core и распространяется 
как отдельный продукт. Qtopia Core обеспечивает базовую функциональность для 
всей линейки платформ, предназначенных для разработки приложений для встраиваемых и 
мобильных устройств (КПК, смартфонов и т. п.).

Начиная с версии 4.5 Qt распространяется по 3 лицензиям:

\begin{enumerate}[label=--]
    \item Qt Commercial -- для разработки ПО с собственнической лицензией, 
          допускающая модификацию самой Qt без раскрытия изменений.
    \item GNU GPL -- для разработки ПО с открытыми исходниками распространяемыми 
          на условиях GNU GPL.
    \item GNU LGPL -- для разработки ПО с собственнической лицензией, но без 
          внесения изменений в Qt.
\end{enumerate}

Со времени своего появления в 1996 году библиотека Qt легла в основу тысяч 
успешных проектов во всём мире. Кроме того, Qt является фундаментом популярной 
рабочей среды KDE, входящей в состав многих дистрибутивов Linux.

Отличительная особенность Qt от других библиотек — использование
Meta Object Compiler (MOC) - предварительной системы обработки исходного кода
(в общем-то, Qt - это библиотека не для чистого C++, а для его особого наречия,
с которого и «переводит» MOC для последующей компиляции любым стандартным C++
компилятором). MOC позволяет во много раз увеличить мощь библиотек, вводя такие
понятия, как слоты и сигналы. Кроме того, это позволяет сделать код более
лаконичным. Утилита MOC ищет в заголовочных файлах на C++ описания классов,
содержащие макрос Q\_OBJECT, и создаёт дополнительный исходный файл на C++,
содержащий мета-объектный код.

Qt позволяет создавать собственные плагины и размещать их непосредственно в
панели визуального редактора. Также существует возможность расширения привычной
функциональности виджетов, связанной с размещением их на экране, отображением,
перерисовкой при изменении размеров окна.

Qt комплектуется визуальной средой разработки графического интерфейса
<<Qt Designer>>, позволяющей создавать диалоги и формы <<мышью>>
(в режиме WYSIWYG). В поставке Qt есть <<Qt Linguist>> - графическая утилита,
позволяющая упростить локализацию и перевод вашей программы на многие языки;
и «Qt Assistant» — справочная система Qt, упрощающая работу с документацией по
библиотеке, а также позволяющая создавать кросс-платформенную справку для
разрабатываемого на основе Qt ПО. Начиная с версии 4.5.0 в комплект Qt
включена среда разработки <<Qt Creator>>, которая включает в себя редактор кода,
справку, графические средства <<Qt Designer>> и возможность отладки
приложений. <<Qt Creator>> может использовать GCC или Microsoft VC++ в качестве
компилятора и GDB в качестве отладчика. Для Windows версий библиотека
комплектуется компилятором, заголовочными и объектными файлами MinGW.

Иерархия основных модулей Qt приведена на рисунке \ref{fig:qt-overview}.

\begin{figure}[h!]
    \centering
    \includegraphics[scale=0.5]{images/qt-overview.png}
    \caption{Иерархия модулей Qt}
    \label{fig:qt-overview}
\end{figure}

\subsection{Обзор SQLite}
\label{subsec:sqlite-overview}

SQLite — легковесная встраиваемая реляционная база данных. Исходный код библиотеки передан в общественное достояние.
Слово «встраиваемый» означает, что SQLite не использует парадигму клиент-сервер, то есть движок SQLite не является отдельно
работающим процессом, с которым взаимодействует программа, а предоставляет библиотеку, с которой программа компонуется и движок 
становится составной частью программы. Таким образом, в качестве протокола обмена используются вызовы функций (API) библиотеки
SQLite. Такой подход уменьшает накладные расходы, время отклика и упрощает программу. SQLite хранит всю базу данных 
(включая определения, таблицы, индексы и данные) в единственном стандартном файле на том компьютере, на котором исполняется
программа. Простота реализации достигается за счёт того, что перед началом исполнения транзакции записи весь файл, хранящий 
базу данных, блокируется; ACID-функции достигаются в том числе за счёт создания файла журнала.
Несколько процессов или потоков могут одновременно без каких-либо проблем читать данные из одной базы. 
Запись в базу можно осуществить только в том случае, если никаких других запросов в данный момент не обслуживается; 
в противном случае попытка записи оканчивается неудачей, и в программу возвращается код ошибки. 
Другим вариантом развития событий является автоматическое повторение попыток записи в течение заданного интервала времени.
В комплекте поставки идёт также функциональная клиентская часть в виде исполняемого файла sqlite3, с помощью которого
демонстрируется реализация функций основной библиотеки. Клиентская часть работает из командной строки, позволяет обращаться
к файлу БД на основе типовых функций ОС.
Благодаря архитектуре движка возможно использовать SQLite как на встраиваемых системах, так и на выделенных машинах
с гигабайтными массивами данных.

Старые версии SQLite были спроектированы без каких-либо ограничений, единственным условием было то, чтобы база данных
умещалась в памяти, в которой все вычисления производились при помощи 32-разрядных целых чисел. Это создавало определённые проблемы.
Из-за того, что верхние пределы не были определены и соответственно
должным образом протестированы, то частенько наружу вылезали ошибки при использовании SQLite в достаточно экстремальных условиях.
И поэтому, в новых версиях SQLite были введены пределы, которые теперь проверяются вместе с общим набором тестов.

Сама библиотека SQLite написана на C; существует большое количество привязок к другим языкам программирования, в том числе C++, Java, VB.NET, Python, Perl, PHP, Tcl (средства для работы с Tcl включены в комплект поставки SQLite), Ruby, Haskell, Scheme, Smalltalk, Lua и Parser, а также ко многим другим. Полный список существующих средств размещён на странице проекта[3].
Простота и удобство встраивания SQLite привели к тому, что библиотека используется в браузерах, музыкальных плеерах и многих других программах.
В частности, SQLite используют:

\begin{enumerate}[label=--]
    \item Adobe Integrated Runtime — среда для запуска приложений (частично);
    \item Gears;
    \item Фреймворк Qt;
    \item Платформа XUL на движке Gecko 1.9, XULRunner 1.9 и, потенциально, все приложения, основанные на этой
          платформе, в том числе Mozilla Firefox (начиная с версии 3.0) и Mozilla Thunderbird (начиная с версии 3.0). В
          качестве примеров XUL-приложений можно привести Songbird и SQLite Manager; 
    \item Skype; 
    \item Некоторые модели GPS-навигаторов Garmin;
    \item Android API;
\end{enumerate}

Многие программы поддерживают SQLite в качестве формата хранения данных (особенно в Mac OS и iPhone OS, Android), в том
числе:

\begin{enumerate}[label=--]
    \item 1С:Предприятие 7.7 (с помощью внешнего компонента);
    \item Adobe Photoshop Lightroom;
    \item FlylinkDC++;
    \item AIMP;
    \item Banshee;
    \item Eserv;
    \item FAR Manager (начиная с версии 3.0);
    \item Gajim;
    \item Google Chrome;
    \item Miranda IM (с помощью плагина драйвера базы данных);
\end{enumerate}

В 2005 году проект получил награду Google-O’Reilly Open Source Awards.
